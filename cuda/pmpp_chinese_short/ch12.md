# 第十二章：归并 (Merge)

## 核心概念

### 12.1 归并定义
将两个**已排序**列表合并成一个排序列表。

```cpp
void merge_sequential(int *A, int m, int *B, int n, int *C) {
    int i = 0, j = 0, k = 0;
    while (i < m && j < n) {
        if (A[i] <= B[j]) {
            C[k++] = A[i++];
        } else {
            C[k++] = B[j++];
        }
    }
    while (i < m) C[k++] = A[i++];
    while (j < n) C[k++] = B[j++];
}
```

### 12.2 Co-rank 函数

**核心思想**：给定输出位置 k，找到对应的输入位置 i 和 j，使得 k = i + j

```cpp
int co_rank(int k, int *A, int m, int *B, int n) {
    int i = min(k, m);
    int j = k - i;
    int i_low = max(0, k - n);
    
    while (true) {
        if (i > 0 && j < n && A[i-1] > B[j]) {
            // i 太大
            int delta = (i - i_low + 1) / 2;
            i -= delta;
            j += delta;
        } else if (j > 0 && i < m && B[j-1] >= A[i]) {
            // i 太小
            int delta = (j - (k - m) + 1) / 2;
            i += delta;
            j -= delta;
        } else {
            return i;
        }
    }
}
```

**复杂度**：$O(\log N)$（二分搜索）

### 12.3 基本并行归并内核

```cpp
__global__ void merge_basic(int *A, int m, int *B, int n, int *C) {
    int tid = blockIdx.x * blockDim.x + threadIdx.x;
    int total = m + n;
    int elem_per_thread = (total + blockDim.x * gridDim.x - 1) / (blockDim.x * gridDim.x);
    
    int k_curr = tid * elem_per_thread;
    int k_next = min((tid + 1) * elem_per_thread, total);
    
    int i_curr = co_rank(k_curr, A, m, B, n);
    int i_next = co_rank(k_next, A, m, B, n);
    int j_curr = k_curr - i_curr;
    int j_next = k_next - i_next;
    
    merge_sequential(&A[i_curr], i_next - i_curr,
                     &B[j_curr], j_next - j_curr,
                     &C[k_curr]);
}
```

**问题**：内存访问不合并

### 12.4 Tiled 归并内核

使用共享内存改善内存合并：

```cpp
__global__ void merge_tiled(int *A, int m, int *B, int n, int *C, int tile_size) {
    __shared__ int A_S[TILE_SIZE];
    __shared__ int B_S[TILE_SIZE];
    
    // 1. 计算块级 co-rank
    int k_block = blockIdx.x * tile_size * 2;
    int i_block = co_rank(k_block, A, m, B, n);
    int j_block = k_block - i_block;
    
    // 2. 合并加载 A 和 B 的 tile 到共享内存
    // (合并访问)
    
    // 3. 线程级 co-rank（在共享内存上）
    // 4. 每个线程执行顺序归并
}
```

### 12.5 循环缓冲区优化

避免重复加载已在共享内存中的数据：

```cpp
// 使用 A_S_start 和 B_S_start 跟踪循环缓冲区起点
int idx = (A_S_start + offset) % tile_size;
```

## 关键要点

| 技术 | 效果 |
|-----|------|
| Co-rank | 确定每个线程的输入范围 |
| Tiling | 改善内存合并 |
| 循环缓冲区 | 减少冗余数据加载 |

### 并行化挑战
- 输入范围**数据依赖**：无法通过简单索引计算确定
- 需要二分搜索（co-rank）确定每个线程的工作范围

### 应用
- 归并排序的核心操作
- MapReduce 框架的 reduce 阶段
