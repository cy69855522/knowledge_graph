# 第十章：规约 (Reduction)

## 核心概念

### 10.1 规约定义
从数组中得出单一值（如求和、最大值、最小值）。

```cpp
// 顺序实现
float sum = 0;
for (int i = 0; i < N; i++) {
    sum += input[i];
}
```

### 10.2 并行规约树
- 时间复杂度：$O(\log N)$
- 工作量：$O(N)$（与顺序相同）

```
第1步: [a0+a1] [a2+a3] [a4+a5] [a6+a7]
第2步: [a0+a1+a2+a3] [a4+a5+a6+a7]
第3步: [a0+a1+a2+a3+a4+a5+a6+a7]
```

### 10.3 简单规约内核（发散版本）

```cpp
__global__ void SimpleSumReduction(float *input, float *output) {
    int i = 2 * threadIdx.x;
    for (int stride = 1; stride < blockDim.x; stride *= 2) {
        if (threadIdx.x % stride == 0) {
            input[i] += input[i + stride];
        }
        __syncthreads();
    }
    if (threadIdx.x == 0) *output = input[0];
}
```

**问题**：控制分歧严重，执行资源利用率低

### 10.4 收敛规约内核（减少分歧）

```cpp
__global__ void ConvergentSumReduction(float *input, float *output) {
    int i = threadIdx.x;
    for (int stride = blockDim.x; stride > 0; stride /= 2) {
        if (threadIdx.x < stride) {
            input[i] += input[i + stride];
        }
        __syncthreads();
    }
    if (threadIdx.x == 0) *output = input[0];
}
```

**优势**：
- 活跃线程连续，减少 warp 内分歧
- 内存访问合并

### 10.5 共享内存优化

```cpp
__global__ void SharedMemReduction(float *input, float *output) {
    __shared__ float input_s[BLOCK_SIZE];
    
    int i = blockIdx.x * blockDim.x * 2 + threadIdx.x;
    // 每个线程加载并相加两个元素
    input_s[threadIdx.x] = input[i] + input[i + blockDim.x];
    __syncthreads();
    
    for (int stride = blockDim.x / 2; stride > 0; stride /= 2) {
        if (threadIdx.x < stride) {
            input_s[threadIdx.x] += input_s[threadIdx.x + stride];
        }
        __syncthreads();
    }
    if (threadIdx.x == 0) output[blockIdx.x] = input_s[0];
}
```

### 10.6 分层规约（任意长度输入）

```cpp
__global__ void SegmentedReduction(float *input, float *output) {
    __shared__ float input_s[BLOCK_SIZE];
    
    int segment = blockIdx.x * blockDim.x * 2;
    int i = segment + threadIdx.x;
    
    input_s[threadIdx.x] = input[i] + input[i + blockDim.x];
    __syncthreads();
    
    for (int stride = blockDim.x / 2; stride > 0; stride /= 2) {
        if (threadIdx.x < stride) {
            input_s[threadIdx.x] += input_s[threadIdx.x + stride];
        }
        __syncthreads();
    }
    
    if (threadIdx.x == 0) {
        atomicAdd(output, input_s[0]);  // 原子操作合并各块结果
    }
}
```

### 10.7 线程粗化

每个线程处理多个元素，减少并行开销：

```cpp
__global__ void CoarsenedReduction(float *input, float *output, int N) {
    __shared__ float input_s[BLOCK_SIZE];
    
    int segment = blockIdx.x * blockDim.x * COARSE_FACTOR * 2;
    int i = segment + threadIdx.x;
    
    // 每个线程累加 COARSE_FACTOR * 2 个元素
    float sum = 0;
    for (int tile = 0; tile < COARSE_FACTOR * 2; tile++) {
        sum += input[i + tile * blockDim.x];
    }
    input_s[threadIdx.x] = sum;
    __syncthreads();
    
    // 树形规约
    for (int stride = blockDim.x / 2; stride > 0; stride /= 2) {
        if (threadIdx.x < stride) {
            input_s[threadIdx.x] += input_s[threadIdx.x + stride];
        }
        __syncthreads();
    }
    
    if (threadIdx.x == 0) atomicAdd(output, input_s[0]);
}
```

## 关键要点

| 优化技术 | 效果 |
|---------|------|
| 收敛模式 | 减少控制分歧，改善内存合并 |
| 共享内存 | 减少全局内存访问 |
| 线程粗化 | 减少并行开销，提高硬件利用率 |
| 分层规约 | 处理任意长度输入 |

### 性能分析
- 简单版本效率：~35%（256元素）
- 收敛版本效率：~66%（256元素）
- 主要瓶颈：后期迭代 warp 内分歧

### 要求
- 运算符必须**可结合**（如加法、max、min）
- 某些优化还要求**可交换**
