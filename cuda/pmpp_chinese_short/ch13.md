# 第十三章：排序

## 核心概念

### 13.1 基数排序 (Radix Sort)

**思想**：按位（或位组）分桶，从低位到高位迭代

```
输入:  [1011, 0110, 1101, 0001, 1000, 0111]
按LSB: [0110, 1000] [1011, 1101, 0001, 0111]  // 0桶, 1桶
按bit1: [1000, 1101, 0001] [0110, 1011, 0111]
...
```

### 13.2 并行基数排序

每个线程负责一个键，使用**排他扫描**确定目标位置：

```cpp
__global__ void radix_sort_iter(int *keys, int *output, int N, int iter) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i >= N) return;
    
    int key = keys[i];
    int bit = (key >> iter) & 1;
    
    // 排他扫描计算 "1" 的数量
    int ones_before = exclusive_scan(bit);
    int total_ones = ...; // 扫描结果
    
    int dest;
    if (bit == 0) {
        dest = i - ones_before;  // 0桶位置
    } else {
        dest = (N - total_ones) + ones_before;  // 1桶位置
    }
    output[dest] = key;
}
```

### 13.3 优化：本地排序 + 合并

```cpp
// 1. 每个块在共享内存中本地排序
__shared__ int local_keys[BLOCK_SIZE];
// 本地基数排序...

// 2. 计算每个块的桶大小
// 3. 扫描确定全局桶位置
// 4. 合并写入全局内存（合并访问）
```

### 13.4 多位基数

使用 r 位基数：
- 迭代次数：$\lceil \frac{N_{bits}}{r} \rceil$
- 桶数量：$2^r$
- 权衡：更少迭代 vs 更多桶

### 13.5 线程粗化

每个线程处理多个键：
- 减少块数量
- 更大的本地桶 → 更好的内存合并

## 归并排序

### 13.6 并行归并排序

```
[8段] → 并行排序各段
  ↓
[4对] → 并行归并
  ↓
[2对] → 并行归并
  ↓
[1对] → 最终归并
```

使用第12章的并行归并算法。

## 其他排序算法

| 算法 | 特点 |
|-----|------|
| 奇偶变换排序 | 简单，$O(N^2)$ |
| 双调排序 | 固定比较模式，适合小序列 |
| 样本排序 | 适合超大分布式数据 |
| MSD基数排序 | 自顶向下，适合大数据 |

## 关键要点

| 优化 | 效果 |
|-----|------|
| 本地排序 | 改善内存合并 |
| 多位基数 | 减少迭代次数 |
| 线程粗化 | 减少扫描开销 |

### 复杂度
- 基数排序：$O(d \cdot N)$，d 为位数
- 归并排序：$O(N \log N)$

### 选择建议
- **基数排序**：整数键，高效但不通用
- **归并排序**：任意比较函数，更通用
