# 第十五章：图遍历 (BFS)

## 核心概念

### 15.1 图表示

#### 邻接矩阵
- A[i][j] = 1 表示从顶点 i 到 j 有边
- 稀疏图使用压缩格式（CSR/CSC/COO）

#### CSR 表示
```cpp
int srcPtrs[];  // 每个顶点出边的起始位置
int dst[];      // 目标顶点
```

### 15.2 广度优先搜索 (BFS)

从根顶点开始，按层级遍历：
- 第 0 级：根顶点
- 第 k 级：从第 k-1 级可达的未访问顶点

### 15.3 以顶点为中心的并行化

#### 推 (Push/Top-Down) - 使用 CSR
```cpp
__global__ void bfs_push(int *srcPtrs, int *dst, int *level, 
                         int currLevel, int numVertices) {
    int v = blockIdx.x * blockDim.x + threadIdx.x;
    if (v < numVertices && level[v] == currLevel - 1) {
        for (int e = srcPtrs[v]; e < srcPtrs[v + 1]; e++) {
            int neighbor = dst[e];
            if (level[neighbor] == UINT_MAX) {
                level[neighbor] = currLevel;
            }
        }
    }
}
```

#### 拉 (Pull/Bottom-Up) - 使用 CSC
```cpp
__global__ void bfs_pull(int *dstPtrs, int *src, int *level,
                         int currLevel, int numVertices) {
    int v = blockIdx.x * blockDim.x + threadIdx.x;
    if (v < numVertices && level[v] == UINT_MAX) {
        for (int e = dstPtrs[v]; e < dstPtrs[v + 1]; e++) {
            int neighbor = src[e];
            if (level[neighbor] == currLevel - 1) {
                level[v] = currLevel;
                break;  // 找到一个即可退出
            }
        }
    }
}
```

| 方法 | 适合阶段 | 原因 |
|-----|---------|------|
| 推 | 早期 | 前沿小，未访问顶点多 |
| 拉 | 后期 | 前沿大，未访问顶点少 |

### 15.4 以边为中心的并行化

```cpp
__global__ void bfs_edge(int *src, int *dst, int *level,
                         int currLevel, int numEdges) {
    int e = blockIdx.x * blockDim.x + threadIdx.x;
    if (e < numEdges) {
        if (level[src[e]] == currLevel - 1 && level[dst[e]] == UINT_MAX) {
            level[dst[e]] = currLevel;
        }
    }
}
```

- ✅ 更多并行性（边数 > 顶点数）
- ✅ 负载均衡（每线程一条边）
- ❌ 检查每条边，即使不相关

### 15.5 边界优化

只处理前沿顶点，避免冗余检查：

```cpp
__global__ void bfs_frontier(int *srcPtrs, int *dst, int *level,
                             int *prevFrontier, int *currFrontier,
                             int *numCurrFrontier, int currLevel) {
    __shared__ int local_frontier[LOCAL_SIZE];
    __shared__ int local_count;
    
    if (threadIdx.x == 0) local_count = 0;
    __syncthreads();
    
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < *numPrevFrontier) {
        int v = prevFrontier[i];
        for (int e = srcPtrs[v]; e < srcPtrs[v + 1]; e++) {
            int neighbor = dst[e];
            // 原子 CAS 避免重复添加
            if (atomicCAS(&level[neighbor], UINT_MAX, currLevel) == UINT_MAX) {
                int idx = atomicAdd(&local_count, 1);
                if (idx < LOCAL_SIZE) {
                    local_frontier[idx] = neighbor;
                }
            }
        }
    }
    __syncthreads();
    
    // 合并到全局边界
    // ...
}
```

### 15.6 私有化优化

每个块维护本地边界，减少原子操作竞争：
- 共享内存存储本地边界
- 最后合并到全局边界

## 关键要点

| 优化 | 效果 |
|-----|------|
| 方向优化 | 根据阶段选择推/拉 |
| 边界 | 只处理相关顶点 |
| 私有化 | 减少原子操作竞争 |
| 负载均衡 | 按顶点度分桶处理 |

### 图结构影响
- **道路网络**：度低且均匀，层数多
- **社交网络**：度高且不均匀，层数少（小世界图）
