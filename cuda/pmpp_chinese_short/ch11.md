# 第十一章：前缀扫描 (Prefix Sum / Scan)

## 核心概念

### 11.1 扫描定义

**包含扫描 (Inclusive Scan)**：
$$[x_0, (x_0 + x_1), (x_0 + x_1 + x_2), ..., (x_0 + ... + x_{n-1})]$$

**排他扫描 (Exclusive Scan)**：
$$[0, x_0, (x_0 + x_1), ..., (x_0 + ... + x_{n-2})]$$

```cpp
// 顺序包含扫描
y[0] = x[0];
for (int i = 1; i < N; i++) {
    y[i] = y[i-1] + x[i];
}
```

### 11.2 Kogge-Stone 算法

**思想**：每次迭代，每个元素加上距离 stride 的前一个元素

```cpp
__global__ void KoggeStone_scan(float *X, float *Y, int N) {
    __shared__ float XY[SECTION_SIZE];
    
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < N) XY[threadIdx.x] = X[i];
    
    for (int stride = 1; stride < blockDim.x; stride *= 2) {
        __syncthreads();
        float temp;
        if (threadIdx.x >= stride) {
            temp = XY[threadIdx.x] + XY[threadIdx.x - stride];
        }
        __syncthreads();
        if (threadIdx.x >= stride) {
            XY[threadIdx.x] = temp;
        }
    }
    
    if (i < N) Y[i] = XY[threadIdx.x];
}
```

**复杂度**：
- 时间：$O(\log N)$
- 工作量：$O(N \log N)$（不是工作高效的）

### 11.3 Brent-Kung 算法

**思想**：两阶段 - 规约树 + 反向树

```cpp
// 阶段1：规约树（向上）
for (int stride = 1; stride < blockDim.x; stride *= 2) {
    int index = (threadIdx.x + 1) * 2 * stride - 1;
    if (index < SECTION_SIZE) {
        XY[index] += XY[index - stride];
    }
    __syncthreads();
}

// 阶段2：反向树（向下）
for (int stride = SECTION_SIZE / 4; stride > 0; stride /= 2) {
    int index = (threadIdx.x + 1) * 2 * stride - 1;
    if (index + stride < SECTION_SIZE) {
        XY[index + stride] += XY[index];
    }
    __syncthreads();
}
```

**复杂度**：
- 时间：$O(\log N)$
- 工作量：$O(N)$（工作高效）

### 11.4 三阶段粗化扫描

```cpp
// 阶段1：每个线程顺序扫描子段
for (int i = 1; i < COARSE_FACTOR; i++) {
    local[i] += local[i-1];
}

// 阶段2：对每个子段的最后元素进行扫描
// (使用 Kogge-Stone 或 Brent-Kung)

// 阶段3：将前一子段的和加到当前子段
for (int i = 0; i < COARSE_FACTOR - 1; i++) {
    local[i] += prev_sum;
}
```

### 11.5 分层扫描（任意长度）

```
输入:     [........segment0........] [........segment1........] ...
           ↓ 块级扫描                  ↓ 块级扫描
扫描块:   [........scan0..........] [........scan1..........] ...
           ↓ 取最后元素                ↓
S数组:    [sum0] [sum1] [sum2] ...
           ↓ 对S扫描
S扫描:    [0] [sum0] [sum0+sum1] ...
           ↓ 加回各段
最终:     各段加上前面所有段的总和
```

### 11.6 单遍扫描（相邻同步）

避免多次内核启动，使用原子操作在块间传递部分和：

```cpp
// 等待前一个块完成
while (atomicAdd(&flags[bid], 0) == 0) {}

// 加载前一个块的部分和
float prev_sum = scan_value[bid];

// 更新并传递给下一个块
atomicAdd(&scan_value[bid + 1], local_sum + prev_sum);
__threadfence();
atomicAdd(&flags[bid + 1], 1);
```

## 关键要点

| 算法 | 时间 | 工作量 | 特点 |
|-----|------|--------|------|
| Kogge-Stone | $O(\log N)$ | $O(N \log N)$ | 简单，适合小段 |
| Brent-Kung | $O(2\log N)$ | $O(N)$ | 工作高效 |
| 粗化扫描 | - | $O(N)$ | 实用，减少并行开销 |

### 应用场景
- 并行资源分配
- 流压缩 (Stream Compaction)
- 基数排序
- 多项式求值
- 将顺序递归转为并行
